(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{584:function(t,e,n){"use strict";n.r(e);var r=n(17),a=Object(r.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("p",[t._v("本篇文章介绍 go 中限流和限速的实现，主要的算法使用到令牌桶，但是本篇文章不会介绍令牌桶算法，默认你已经明白令牌桶的原理。")]),t._v(" "),n("h2",{attrs:{id:"限流"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#限流"}},[t._v("#")]),t._v(" 限流")]),t._v(" "),n("p",[t._v("限流是后台系统中常见的一个需求，最简单的是根据 IP 地址对请求频率做一个限制，使用 "),n("a",{attrs:{href:"https://pkg.go.dev/golang.org/x/time/rate",target:"_blank",rel:"noopener noreferrer"}},[t._v("time/rate"),n("OutboundLink")],1),t._v(" 包可以很容易实现这个需求。")]),t._v(" "),n("div",{staticClass:"language-golang extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("type IPLimit struct {\n\tmutex   sync.Mutex\n\tiprates map[string]*rate.Limiter\n}\n\nvar limiter *IPLimit\n\nfunc init() {\n\tlimiter = &IPLimit{\n\t\tiprates: make(map[string]*rate.Limiter),\n\t}\n}\n")])])]),n("p",[t._v("为了实现根据 IP 限流，需要一个 map 结构来保存 IP 和 rate.Limiter 的关系，接下来我们就一个在 middleware 中使用了：")]),t._v(" "),n("div",{staticClass:"language-golang extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('func IPLimitRaterMiddleware(c *gin.Context) {\n\n\tip := c.ClientIP()\n\t\n    limiter.mutex.Lock()\n\tdefer limiter.mutex.Unlock()\n\n\tl, ok := limiter.iprates[ip]\n\tif !ok {\n\t\tl = rate.NewLimiter(1, 10)\n\t\tlimiter.iprates[ip] = l\n\t}\n\n\tif !l.Allow() {\n\t\tc.AbortWithStatusJSON(http.StatusTooManyRequests, gin.H{\n\t\t\t"message": "too many requests",\n\t\t})\n\t\treturn\n\t}\n\tc.Next()\n}\n')])])]),n("p",[t._v("这里 "),n("code",[t._v("l.Allow()")]),t._v(" 是关键，如果请求频率已经超过令牌桶设置的频率，那么 "),n("code",[t._v("Allow()")]),t._v(" 返回 false，根据这个返回值就可以返回 429 了。")]),t._v(" "),n("p",[t._v("使用 time/rate 包实现限流很简单，但是上面的做法是有缺陷的："),n("strong",[t._v("所有的请求都需要争 IPLimit 的锁。")]),t._v(" 在这里我们用 map 保存 IP 地址和令牌桶的关系，但是由于 map 不支持并发读写，所以在读写之前需要使用 sync.Mutex 锁住 map，这使得这里的代码会成为一个瓶颈。如果要提高性能，应该将这里的 map 改成 sync.Map 等支持并发读写的 map，或者使用 redis 来实现限流")]),t._v(" "),n("h2",{attrs:{id:"限速"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#限速"}},[t._v("#")]),t._v(" 限速")]),t._v(" "),n("p",[t._v("go 中的限速是指在使用 gin 之类的 http server 下载文件，希望服务端可以控制下载速度。 其实，go 限流的实现在网上可以看到很多讲解，但是关于限速的实现却很少。")]),t._v(" "),n("p",[t._v("如何实现限速，这个需求看似很接近限流，但是具体事项起来却比较不好下手，这里我们先不管限速，来看看使用 gin 如何实现下载文件。")]),t._v(" "),n("div",{staticClass:"language-golang extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('r.GET("/download_1", func(c *gin.Context) {\n\t\t//RandStringBytesMaskImprSrc 函数可以生成一个指定大小的 []byte，这里生成的是一个 10MB 的 []byte\n\t\tb := RandStringBytesMaskImprSrc(10 * 1024 * 1024)\n\t\tbuf := bytes.NewBuffer(b)\n\t\tc.Header("Content-Length", fmt.Sprintf("%d", len(b)))\n\t\tc.Header("Content-disposition", "attachment;filename=download")\n\t\tio.Copy(c.Writer, buf)\n\t})\n')])])]),n("p",[t._v("上面几行代码就可以实现下载功能了，请求 "),n("code",[t._v("/download_1")]),t._v(" 可以下载一个 download 的文件，可以看到下载的主要逻辑是："),n("code",[t._v("io.Copy(c.Writer, buf)")]),t._v("，"),n("code",[t._v("c.Writer")]),t._v(" 为 http 请求代表的 socket，这里看到下载的本质是将流写到 "),n("code",[t._v("c.Writer")]),t._v(" 中。那么如果我们现在写入的速度，就可以做到限速：")]),t._v(" "),n("div",{staticClass:"language-golang extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('b := RandStringBytesMaskImprSrc(10 * 1024 * 1024)\nbuf := bytes.NewBuffer(b)\nc.Header("Content-Length", fmt.Sprintf("%d", len(b)))\nc.Header("Content-disposition", "attachment;filename=download")\n\n//每秒写 10*1024 byte 到 c.Writer\nfor range time.Tick(1 * time.Second) {\n\t_, err := io.CopyN(c.Writer, buf, 10*1024) //10KB/s\n\tif err == io.EOF {\n\t\tbreak\n\t}\n}\n')])])]),n("p",[t._v("这里每隔 1s 往 "),n("code",[t._v("c.Writer")]),t._v(" 写入 10KB/s 的数据，这样下载速率就可以控制在 10KB/s 了。")]),t._v(" "),n("p",[t._v("除了使用 "),n("code",[t._v("time.Tick")]),t._v(" 之外，同样也可以使用令牌桶算法来实现限速")]),t._v(" "),n("div",{staticClass:"language-golang extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("type LimitReader struct {\n\tr       io.Reader\n\tlimiter *rate.Limiter\n\tctx     context.Context\n}\n\nconst burstLimit = 1000 * 1000 * 1000\n\nfunc NewLimitReader(r io.Reader) *LimitReader {\n\treturn &LimitReader{\n\t\tr:   r,\n\t\tctx: context.Background(),\n\t}\n}\n\nfunc (s *LimitReader) SetRateLimit(bytesPerSec float64) {\n\ts.limiter = rate.NewLimiter(rate.Limit(bytesPerSec), burstLimit)\n\ts.limiter.AllowN(time.Now(), burstLimit)\n}\n\nfunc (s *LimitReader) Read(p []byte) (int, error) {\n\tif s.limiter == nil {\n\t\treturn s.r.Read(p)\n\t}\n\tn, err := s.r.Read(p)\n\tif err != nil {\n\t\treturn n, err\n\t}\n\t//当读取的速率超过令牌桶设置的速率，会阻塞在 WaitN \n\tif err := s.limiter.WaitN(s.ctx, n); err != nil {\n\t\treturn n, err\n\t}\n\treturn n, nil\n}\n")])])]),n("div",{staticClass:"language-golang extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('r.GET("/download_2", func(c *gin.Context) {\n\tb := RandStringBytesMaskImprSrc(10 * 1024 * 1024)\n\tbuf := bytes.NewBuffer(b)\n\tc.Header("Content-Length", fmt.Sprintf("%d", len(b)))\n\tc.Header("Content-disposition", "attachment;filename=download")\n\n\tlr := flowlimit.NewLimitReader(buf)\n\tlr.SetRateLimit(10 * 1024) //设置下载速率\n\tio.Copy(c.Writer, lr)\n})\n')])])]),n("p",[t._v("上面就是使用令牌桶做限速的逻辑了，这里我们对 reader 做了封装，"),n("code",[t._v("io.Copy")]),t._v(" 会调用 "),n("code",[t._v("LimitReader")]),t._v(" 的 "),n("code",[t._v("Read")]),t._v(" 函数读取数据，这里我们在 "),n("code",[t._v("Read")]),t._v(" 中使用令牌桶做了限制：如果读取速率超过令牌桶的速率，那么就会阻塞在 "),n("code",[t._v("WaitN")]),t._v("，这样就实现了限速的功能。")])])}),[],!1,null,null,null);e.default=a.exports}}]);